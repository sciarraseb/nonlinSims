---
title: "Using nonlinSims"
author: "Sebastian Sciarra"
date: "September 15, 2021"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using nonlinSims}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#library(devtools)
#install_github("sciarraseb/nonlinSims", dependencies = T, force=T)
#library(easypackages)
#library(nonlinSims)
#library(parallel)
#library(tidyverse)
#ibrary(OpenMx)
library(easypackages)
packages <- c('nonlinSims', 'parallel', 'tidyverse', "OpenMx", "data.table")
libraries(packages)


#packages to load: tidyverse, data.table, 
```


# Experiment 1 (Does equal spacing perform best across all patterns of s-shaped change?)

To test whether equal spacing should be used when one does not know the pattern of s-shape change, Experiment 1 will manipulate the 
pattern of change, measurement spacing, and the number of measurements. Measurement spacing will be manipulated such that measurements
are either separated by equal-length intervals, intervals that increase in length over time (*time-increasing spacing*), intervals that
decrease in length over time (*time-decreasing spacing*), or intervals that separate measurements at the beginning, middle, and end of
the measurement window (*middle-and-extreme spacing*). Number of measurements will be manipulated to either be 5, 7, 9, or 11 
measurements. The patterns of s-shape change will be manipulated by modulating the midpoint parameters, thus shifting the inflection 
point. Change will be assumed to occur over a 360-day period. Sample size will be fixed at 225. 


```{r generate-thee-param-data, echo=F}
#fixed effects
sd_scale <- 1.5
common_effect_size <- 0.32
diff_fixed <- sd_scale * common_effect_size

num_measurements <- 9
time_period <- 360
scaling_factor <- time_period/num_measurements

gamma_fixed <- 20

#random effects 
sd_diff <- 0.15
sd_beta <- 10
sd_gamma <- 5
sd_error <- 0.05

#correlations
cor_diff_beta <- 0
cor_diff_gamma <- 0
cor_beta_gamma <- 0
scaling_constant <- 3
                              

#INDEPENDENT VARIABLE SETUP (note that sample size is fixed at 225)
##Set beta values at 80, 180, and 280 
beta_fixed <- seq(from = 80, to = 280, by = 100)[1]

#Set number of measurements to either 5, 7, 9, or 11
num_measurements <- seq(from = 5, to = 11, by = 2)[4]

##Iterate through all four spacing conditions: equal, time_inc, time_dec, and middle_ext
schedule <- compute_measurement_schedule(time_period = 360, num_measurements = num_measurements, base_time_length = 30, measurement_spacing = 'equal')

#Set up of population-level parameters
pop_params <- generate_three_param_pop_curve(diff_fixed = diff_fixed, beta_fixed = beta_fixed, gamma_fixed = gamma_fixed, 
                               sd_diff = sd_diff, sd_beta = sd_beta, sd_gamma = sd_gamma, sd_error = sd_error, 
                               cor_diff_beta = cor_diff_beta, cor_diff_gamma = cor_diff_gamma, cor_beta_gamma = cor_beta_gamma,
                               scaling_constant = scaling_constant)




factor_list <- list(spacing = c("equal", "time_inc", "time_dec", "mid_ext"),
                      num_measurements = seq(from = 5, to = 11, by = 2), 
                      midpoint =  seq(from = 80, to = 280, by = 100))

factor_list <- list(spacing = c("equal"),
                    num_measurements = seq(from = 9, to = 11, by = 2), 
                    midpoint =  seq(from = 80, to = 80, by = 100))

devtools::load_all()
test_convergence(factor_list = factor_list, num_iterations = 2, pop_params = pop_params, response_group_size = 225, num_cores = 3)


```




```{r errors-to-fix}
#1. Even number of measurements for compute measurement schedule. 
#2. 

```


# Code tests 

```{r starting-value-procedure, echo=F}
#Fixed_effect starting values  
#In MPlus framework, w represents starting values (pg. 520 of manual; defaults for growth models)
##fixed-effect values for  are obtained using self-starting function and not fitting any nonlinear regression model to the data (fitting a 
#model at this stage can yield impossible values). Also note that starting value for diff_fixed is calculated by subtracting mean ending value from mean
#beginning value
##In Mplus, automatic starting values for the growth factor means and variances are generated based on individual regressions of the outcome variable on time. 
##Unfortunately, following this approach in this specific situation with nonlinear models can hijacks the starting value procedure (see above comment). 
fixed_effect_starts <- logistic_self_start(data = data)

#Random-effect starting values 
##diff_rand is obtained by obtaining variance of change scores from each person (i.e., var((score_final_time_point - score_final_time_point))
diff_rand_start <- compute_diff_rand_start(data)

rand_starts <- compute_rand_effect_starts(data = data,time_rand_effects = c('beta_rand', 'gamma_rand'))
fixed_starts <- compute_fixed_effect_starts(data = data, rand_effect_starts = rand_starts)


#w  + srb
##r = unif(-0,5, 0.5) 
##s = 5 (determines strength of random perturbation)
##b = base scale variable = 2max{sqrt(var), 1}, where var = starting value for variance of parameter
###b for diff_fixed = 2 (almost all of the time)
###b for beta_fixed = sqrt(var) almost all of the time 
###b for gamma_fixed = sqrt(var) almost all of the time
###b for random effects and residual variance = 0 (i.e., no perturbation in generation process of random variables or residual variance)

#Residual variance starting value (Hipp & Bauer, 2006)
##20-80% of observed variance (averaged across each time point)
res_var <- compute_residual_start_value(data_wide = data_wide)

```

```{r echo=F}
num_flips <- 10
prob_success <- 0.2
num_successes <- 2

(factorial(num_flips)/(factorial(num_successes)*factorial(num_flips-num_successes)))*prob_success^num_successes*(1-prob_success)^(num_flips-num_successes)


factorial(num_flips)/(factorial(num_successes)*factorial(num_flips-num_successes)) #represents total number of ways two sucesses can be obtained 
prob_success^num_successes #represents probability of having given probability of success on all successful trials 
prob_success^num_successes*(1-prob_success) #represents probability of having given probability of failure on all failed trials 

#solving for the probability of success
num_flips <- 10
num_successes <- 7
prob_success <- 0.9

(factorial(num_flips)/(factorial(num_successes)*factorial(num_flips-num_successes)))*prob_success^num_successes*(1-prob_success)^(num_flips-num_successes)


```


# Appendix 
## Apppendix A: Computation of spacing for time-increasing and time-decreasing conditions 

Several attempts were made to compute interval lengths such that they were of integer lengths. Unfortunately, it was not possible to find a set of intervals that followed the equation
$i_{length} = kc + b$ (where $c$ represents the constant length and $b$ represents the base length) such that all interval lengths were of integer values. The code below shows that, 
for all base lengths of 1--30 days (assuming a time period of 360 days), no set of intervals is only integes. 

```{r time_inc-interval-calculations, echo=T}

compute_time_increasing_intervals <- function(time_period, num_measurements, base_time_length) {

  #compute length of constant by first calculating how many days remain after subtracting base_time_length for each interval.
  ##num_measurements-1 = number of intervals
  remaining_num_days <- time_period - (num_measurements-1)*base_time_length
  ##The number of constants = num_measurements - 1
  constant_length <- remaining_num_days/sum(seq(0,(num_measurements-2)))

  interval_lengths <- seq(0,(num_measurements-2))*constant_length + base_time_length
  return(interval_lengths)
}

testx <- function() {
  for (base_time_length in seq(1:30)) {
    print(base_time_length)
    print("=================")
    for (num_measurements in c(5, 7, 9, 11)) {
      xo <- get_stuff(n = n, x = x)
      xo <- c(n, xo, sum(xo))
      print(sprintf("%1.3f",xo))
    }
    print("=================")
  }
}




```

## Appendix B: Other functions

```{r other-functions, echo=F}

```

## Appendix C: 
