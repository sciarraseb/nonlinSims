---
title: "How to use EM algorithm with nonlinear latent growth curve model?"
output: pdf_document
bibliography: references.bib
---

```{r setup, warning=F, message=F}
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 40))

packages <- c('tidyverse', 'OpenMx', 'data.table')
library(easypackages)
libraries(packages)

```

## Inquiry 1 (How to use EM algorith with nonlinear latent growth curve model?)
I am trying to fit a nonlinear latent growth curve model (as part of simulations I am conducting) using a three-parameter logistic function below 


$$ y_{obs} = \frac{diff}{1+e^{\frac{\beta - time_i}{\gamma}}},$$


where $diff$ represents the difference between the starting and ending values (i.e., how much change occurs over time), $\beta$ represents the number of days needed to reach the midpoint
of the logistic curve, and $\gamma$ represents the number of days needed to go from the midpoint to approximately 73% of the observed change (i.e., a satiation point). Because the SEM framework only allows any given outcome variable to be predicted as a weighted sum of the predictors (i.e., SEM framework is inherently linear), the logistic function cannot simply be inserted into a latent growth curve model. As per the structured latent curve approach outlined in several articles [e.g., @browne1993; @grimm2010; @preacher2015], I linearized the logistic function (Equation \@ref(eq:logFunction)) using a first-order Taylor series expansion. 

The code below outlines the nonlinear latent growth curve model that I have fitted to a data set I have generated (`data_wide.csv`). The generated data set contains scores from 100 people
measured at five points over a year period (specifically on days 1, 150, 180, 210, and 360) and is generated from a population model where change is logistic. I have also attached a 
set of starting values (generated by largely copying the starting value procedure in MPlus) to initialize parameter estimation. 

Given that my model contains latent variables (i.e., diff, beta, and gamma), I would like to use a parameter estimation algorithm that is well suited to dealing with latent variables. 
From what I understand, the `mxFitFunctionML()` function uses full information maximum likelihood (FIML) estimation to estimate parameter values when raw data are used (as in my case).
Unfortunately, (and from what I have understand about estimation algorithms), FIML estimation is not well suited to dealing with latent variables since it does not iteratively compute
lower bounds of the marginal log-likelihood and maximize these lower bounds (i.e., the e- and m-steps of the EM algorithm). Given the iterative nature of the EM algorithm, it makes sense
that I have realized considerable performance improvements (both in time and parameter estimation accuracy) when using the EM algorithm (versus FIML) in fitting growth mixture models.

Although I was successful in implementing the EM algorithm for a growth mixture model, it was largely due to the fact that I copied over the example code from the documentation of 
`mxComputeEM()`. I have looked at other posts on forums and have not been able to work out how to implement the EM algorithm for my nonlinear latent growth curve model.


```{r nonlin-lgc, echo=F}
data_wide <- read.csv('data_wide.csv') 

#data table of randomly generated starting values (procedure largely mirrors process followed in MPlus)
starting_values <- data.table(beta_fixed = 65.57385, 
                              gamma_fixed = 20, 
                              diff_fixed = 80, 
                              beta_rand = 21.75747, 
                              gamma_rand = 0.5, 
                              diff_rand = 0.8290784, 
                              epsilon = 0.5
)

#setup variables 
manifest_vars <- c("t1_1", "t2_150", "t3_180", "t4_210", "t5_360")
latent_vars <- c('diff', 'beta', 'gamma')

measurement_days <- as.numeric(str_extract(string = names(data_wide[ 2:ncol(data_wide)]), 
                                           pattern = '[^_]*$')) #1 150 180 210 360; sets values for 'time' object

#code adapted from Grimm, Ram, & Estabrook (2016; Chapter 12) 
model <- mxModel(model = 'nonlin_lgc',
                 type = 'RAM',
                 mxData(observed = data_wide, type = 'raw'),
                 
                 manifestVars = manifest_vars,
                 latentVars = latent_vars,
                 
                 #Manifest means
                 manMeans = mxPath(from = 'one', to = manifest_vars, free = FALSE, arrows = 1, values = 0),
                 
                 #Latent variable means (linear parameters). 
                 ##Note that the nonlinear parameters (i.e., beta, gamma) do not have estimated means
                 mxPath(from = 'one', to = c('diff'),free = TRUE, arrows = 1, values = starting_values$diff_fixed,
                        labels = 'diff', lbound = 0, ubound = 2),
                 
                 #Residual variances; by using one label, they are assumed to all be equal (homogeneity of variance)
                 mxPath(from = manifest_vars,
                        arrows=2, free=TRUE, values = starting_values$epsilon, labels='epsilon', lbound = 1e-3),
                 
                 #Latent variable covariances and variances
                 mxPath(from = latent_vars,
                        connect='unique.pairs', arrows=2,
                        #aa(var_diff), ab(cov_diff_beta), ac(cov_diff_gamma), bb(var_beta), bc(var_beta_gamma), cc(var_gamma)
                        free = c(TRUE,
                                 FALSE, FALSE,
                                 TRUE, FALSE, TRUE),
                        values=c(starting_values$diff_rand,
                                 NA,NA,
                                 starting_values$beta_rand, NA, starting_values$gamma_rand),
                        labels=c('var_diff',
                                 'NA(cov_diff_beta)','NA(cov_diff_gamma)',
                                 'var_beta', 'NA(var_beta_gamma)', 'var_gamma'), 
                        lbound = c(1e-3, 
                                   NA, NA, 
                                   1, NA, 1)), 
                 
                 #Functional constraints
                 mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                          values = starting_values$diff_fixed, labels = 'diff', name = 'd', lbound = 0, ubound = 2),
                 mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                          values = starting_values$beta_fixed, labels = 'beta', name = 'b', lbound = 0, ubound = 360),
                 mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                          values = starting_values$gamma_fixed, labels = 'gamma', name = 'g', lbound = 0, ubound = 360),
                 mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = FALSE, 
                          values = measurement_days, name = 'time'),
                 
                 #partial derivative of logistic function with respect to each parameter (diff, beta, gamma, respectively)
                 mxAlgebra(expression = 1/(1 + exp((beta - time)/gamma)), name="Dl"), 
                 mxAlgebra(expression =  -(diff*(exp((beta - time)/gamma) * (1/gamma))/(1 + exp((beta - time)/gamma))^2), name = 'Bl'),
                 mxAlgebra(expression =  diff * (exp((beta - time)/gamma) * ((beta - time)/gamma^2))/(1 + exp((beta - time)/gamma))^2, name = 'Gl'),
                 
                 #Factor loadings; all fixed and, importantly, constrained to equal their partial derivatives 
                 mxPath(from = 'diff', to = manifest_vars, arrows=1, free=FALSE,
                        labels = c("Dl[1,1]", "Dl[2,1]", "Dl[3,1]", "Dl[4,1]", "Gl[5,1]")),
                 mxPath(from='beta', to = manifest_vars, arrows=1,  free=FALSE,
                        labels =  c("Bl[1,1]", "Bl[2,1]", "Bl[3,1]", "Bl[4,1]", "Gl[5,1]")),
                 mxPath(from='gamma', to = manifest_vars, arrows=1,  free=FALSE,
                        labels =  c("Gl[1,1]", "Gl[2,1]", "Gl[3,1]", "Gl[4,1]", "Gl[5,1]")),

                #Enable likelihood vector; returns vector of likelihoods for each data point (i.e., p(X|parameter_values))
                mxFitFunctionML()
                
#implement EM algorithm to estimate parameter values??

)

mxRun(model)

starting_values_dt <- generate_multiple_starting_value_sets(num_sets = 50, time_fixed_effects = c('beta_fixed', 'gamma_fixed'),
                                            time_rand_effects = c('beta_rand', 'gamma_rand'), 
                                            diff_effects = c('diff_fixed', 'diff_rand'), 
                                            error = c('epsilon'))

#update starting values 
update_starting_values <- function(model, starting_values){
  
  
}
names(starting_values)
names(omxGetParameters(model))
omxSetParameters(model = model, 


```


```{r em-code, eval=F}
#not sure how to repurpose this code for the nonlinear latent growth curve model 
mxModel(
  "Mixture", data4mx, class1, class2,
  mxAlgebra((1-Posteriors) * Class1.fitfunction, name="PL1"),
  mxAlgebra(Posteriors * Class2.fitfunction, name="PL2"),
  mxAlgebra(PL1 + PL2, name="PL"),
  mxAlgebra(PL2 / PL,  recompute='onDemand',
            initial=matrix(runif(N,.4,.6), nrow=N, ncol = 1), name="Posteriors"),
  mxAlgebra(-2*sum(log(PL)), name="FF"),
  mxFitFunctionAlgebra(algebra="FF"),
  mxComputeEM(
    estep=mxComputeOnce("Mixture.Posteriors"),
    mstep=mxComputeGradientDescent(fitfunction="Mixture.fitfunction")))

```

## Inquiry 2

I have tried fitting the nonlinear latent growth curve model to the data (`data_wide.csv`) set with 300 sets of starting values (`starting_values.csv`) and have not been able to find 
a solution (only status codes of 5 and 6 were obtained). I then tried fitting the model using an ideal set of starting values (where the starting values are already quite close to the
population values; `ideal_starting_values`), but this also failed to converge (only status codes of 5 and 6 were obtained; I consequently consulted the following link on status codes but
could not solve the issue). The population values that were used to generate the model are listed below:

* `diff_fixed` = 0.48 
* `beta_fixed` = 60
* `gamma_fixed`= 20

* `diff_rand` = 0.30^2
* `beta_rand` = 5^2
* `gamma_rand`= 5^2
* `epsilon` = 0.25^2

\noindent
The parameter values were used with the logistic function below to generate observed scores for each *j* individual at each *i* time point: 

$$ y_{ij} = \frac{diff_i}{1+e^{\frac{\beta_i - time_i}{\gamma_i}}} + \epsilon_{ij}$$
Note that all covariances have been set to zero. Also note that I have nested code within functions to allow a more efficient (and readable) model fitting procedure. The necessary functions are provided in the code chunk below. 

```{r necessary-functions, echo=F}
#generates names for manifest variables (this is nested within create_logistic_growth_model)
generate_manifest_var_names <- function(data_wide) {
  
  manifest_names <- names(data_wide[ , 2:ncol(data_wide)])
  return(manifest_names)
}

#create nonlinear latent growth curve model 
create_logistic_growth_model <- function(data_wide, model_name, starting_values) {

  manifest_vars <- generate_manifest_var_names(data = data_wide)
  latent_vars <- c('diff_fixed', 'beta_fixed', 'gamma_fixed')
  measurement_days <- as.numeric(str_extract(string = names(data_wide[ 2:ncol(data_wide)]), pattern = '[^_]*$'))

  model <- mxModel(model = model_name,
                   type = 'RAM', independent = T,
                   mxData(observed = data_wide, type = 'raw'),
                   
                   manifestVars = manifest_vars,
                   latentVars = latent_vars,
                   
                   #Manifest means
                   manMeans = mxPath(from = 'one', to = manifest_vars, free = FALSE, arrows = 1),
                   
                   #Latent variable means (linear parameters). Note that the nonlinear parameters of beta and gamma do not have estimated means
                   mxPath(from = 'one', to = c('diff_fixed'),free = TRUE, arrows = 1, values = starting_values$diff_fixed,
                          labels = 'diff_fixed', lbound = 0, ubound = 2),
                   
                   #Residual variances; by using one label, they are assumed to all be equal (homogeneity of variance)
                   mxPath(from = manifest_vars,
                          arrows=2, free=TRUE, values = starting_values$epsilon, labels='epsilon', lbound = 1e-3),
                   
                   #Latent variable covariances and variances
                   mxPath(from = latent_vars,
                          connect='unique.pairs', arrows=2,
                          #aa(diff_rand), ab(cov_diff_beta), ac(cov_diff_gamma), bb(beta_rand), bc(var_beta_gamma), cc(gamma_rand)
                          free = c(TRUE,
                                   FALSE, FALSE,
                                   TRUE, FALSE, TRUE),
                          values=c(starting_values$diff_rand,
                                   NA,NA,
                                   starting_values$beta_rand, NA, starting_values$gamma_rand),
                          labels=c('diff_rand',
                                   'NA(cov_diff_beta)','NA(cov_diff_gamma)',
                                   'beta_rand', 'NA(var_beta_gamma)', 'gamma_rand'), 
                          lbound = c(1e-3, 
                                     NA, NA, 
                                     1, NA, 1)),
                   
                   #Functional constraints
                   mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                            values = starting_values$diff_fixed, labels = 'diff_fixed', name = 'd',  lbound = 0, ubound = 2),
                   mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                            values = starting_values$beta_fixed, labels = 'beta_fixed', name = 'b', lbound = 0, ubound = 360),
                   mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = TRUE, 
                            values = starting_values$gamma_fixed, labels = 'gamma_fixed', name = 'g', lbound = 0, ubound = 360),
                   mxMatrix(type = 'Full', nrow = length(manifest_vars), ncol = 1, free = FALSE, values = measurement_days, name = 'time'),
                   
                   mxAlgebra(expression = 1/(1 + exp((beta_fixed - time)/gamma_fixed)), name="Dl"),
                   mxAlgebra(expression =  -(diff_fixed*(exp((beta_fixed - time)/gamma_fixed) * 
                                                           (1/gamma_fixed))/(1 + exp((beta_fixed - time)/gamma_fixed))^2), name = 'Bl'),
                   mxAlgebra(expression =  diff_fixed * (exp((beta_fixed - time)/gamma_fixed) * ((beta_fixed - time)/gamma_fixed^2))/
                               (1 + exp((beta_fixed - time)/gamma_fixed))^2, name = 'Gl'),
                   
                   #Factor loadings; all fixed and, importantly, constrained to change according to their partial derivatives (i.e., nonlinear functions) 
                   mxPath(from = 'diff_fixed', to = manifest_vars, arrows=1, free=FALSE,
                          labels = sprintf(fmt = 'Dl[%d,1]', 1:length(manifest_vars))),
                   mxPath(from='beta_fixed', to = manifest_vars, arrows=1,  free=FALSE,
                          labels =  sprintf(fmt = 'Bl[%d,1]', 1:length(manifest_vars))),
                   mxPath(from='gamma_fixed', to = manifest_vars, arrows=1,  free=FALSE,
                          labels =  sprintf(fmt = 'Gl[%d,1]', 1:length(manifest_vars))),
                   
                   mxFitFunctionML()
                   )
  
  return(model)
}


#changes starting values of model created from create_logistic_growth_model
update_starting_values <- function(model_number, model, starting_values){
  
  param_name_order <- names(omxGetParameters(model))

    #set model with new starting values  
    model_name <- paste("Iteration", model_number, sep="")
    new_model <- omxSetParameters(model = model, 
                                  name = model_name,
                                  labels = param_name_order, 
                                  values = as.numeric(setcolorder(x = starting_values[model_number, ], 
                                                                  neworder = param_name_order)))
    
    #return model with new starting values  
    return(new_model)
}

#iterates update_starting_values to create a parent model where each submodel has different starting values 
assemble_model_starts <- function(model, starting_values) {
  
  parent_model <- mxModel(name = "parent_model")
  sub_models <- lapply(X = 1:nrow(starting_values), FUN = update_starting_values, model = model, starting_values = starting_values)
  merged_model <- mxModel(parent_model, sub_models)
  
  return(merged_model)
}

#extract necessary information about fit from each submodel 
extract_fit_info <- function(model){
  
  retval  <- c(
      model$output$fit,
      model$output$status$code,
      model$output$iterations)
      #round(model$expectation$output$weights[1], 4)) #temporarily omitted 
  return(retval)
}
```

\noindent
Code attempts to find a solution by fitting a nonlinear latent growth curve model with 300 sets of starting values. 

```{r snowfall-procedure, echo=F}
library(OpenMx)
library(data.table)
library(stringr)
library(snowfall)

#read in starting values and raw data sets
starting_values <- read_csv('starting_values.csv')
data_wide <- read_csv('data_wide.csv')

#create nonlinear latent growth curve model 
latent_growth_model <- create_logistic_growth_model(data_wide = data_wide, 
                                                    model_name = 'lg_nonlinear', starting_values = starting_values[1, ])

#run submodel creation and model fitting in parallel model
sfInit(parallel = TRUE, cpus = detectCores() - 1) #save 1 core to prevent computer from crashing
sfLibrary(OpenMx)

#create submodels that each have a different set of starting values 
merged_models <- assemble_model_starts(model = latent_growth_model, starting_values = starting_values)

#run all models 
output <- mxRun(merged_models, unsafe = T)

resultsFit  <- data.table(t(omxSapply(output$submodels, fitStats)))
names(resultsFit) <- c("fit", "status_code", "num_iterations")
sum(resultsFit$status_code == 0) #0

sfStop() #close parallel model 


ideal_starting_values <- data.table('beta_fixed' = 67, 
                                    'gamma_fixed' = 15, 
                                    'beta_rand' = 25, 
                                    'gamma_rand' = 20, 
                                    'diff_fixed' = 0.7,
                                    'diff_rand' = 0.6, 
                                    'epsilon' = 2)
 
latent_growth_model_ideal <- create_logistic_growth_model(data_wide = data_wide, 
                                                    model_name = 'lg_nonlinear', starting_values = ideal_starting_values)
 
first_run <- mxRun(latent_growth_model_ideal) #status code 6
 
mxRun(first_run) #status code 5 
 
mxTryHard(latent_growth_model_ideal)

```
\noindent
I also tried fitting the above model fitting procedure with larger samples sizes and a more ideal set of measurement days (e.g., 1, 90, 280, 270, 360) but had no success. I have not 
included code for these tests largely because the data in `data_wide.csv` represent a fairly non-optimal condition in my simulations and I assume that if I can devise a model fitting 
procedure that succeeds under these conditions, then the procedure will succeed under more ideal conditions. 


Code below fits model with ideal set of starting values (not sure if this is a useful test). 

```{r ideal-starting-values, echo=F}
ideal_starting_values <- data.table('beta_fixed' = 67, 
                                    'gamma_fixed' = 15, 
                                    'beta_rand' = 25, 
                                    'gamma_rand' = 20, 
                                    'diff_fixed' = 0.7,
                                    'diff_rand' = 0.6, 
                                    'epsilon' = 0.9)

latent_growth_model_ideal <- create_logistic_growth_model(data_wide = data_wide, 
                                                    model_name = 'lg_nonlinear', starting_values = ideal_starting_values)

first_run <- mxRun(latent_growth_model_ideal) #status code 6

mxRun(first_run) #status code 5 

mxTryHard(latent_growth_model_ideal) #All fit attempts resulted in errors 
```

